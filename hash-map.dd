Ddoc

$(SPEC_S Associative Arrays,

	$(P Associative arrays have an index that is not necessarily an integer,
	and can be sparsely populated. The index for an associative array
	is called the $(I key), and its type is called the $(I KeyType).
	)

	$(P Associative arrays are declared by placing the $(I KeyType)
	within the [] of an array declaration:
	)

---------
int[string] b;		// associative array b of ints that are
			// indexed by a string.
			// The $(I KeyType) is string
b["hello"] = 3;		// set value associated with key "hello" to 3
func(b["hello"]);	// pass 3 as parameter to func()
---------

	$(P Particular keys in an associative array can be removed with the
	remove function:
	)

---------
b.$(B remove)("hello");
---------

	$(P The $(I InExpression) yields a pointer to the value
	if the key is in the associative array, or $(B null) if not:
	)

---------
int* p;
p = ("hello" $(B in) b);
if (p != $(B null))
	...
---------

	$(P $(I KeyType)s cannot be functions or voids.
	)

	$(P The element types of an associative array cannot be functions or voids.)

<h3>Using Classes as the KeyType</h3>

	$(P Classes can be used as the $(I KeyType). For this to work,
	the class definition must override the following member functions
	of class $(TT Object):)

	$(UL
	$(LI $(TT hash_t toHash()))
$(V1	$(LI $(TT int opEquals(Object))))
$(V2	$(LI $(TT bool opEquals(Object))))
	$(LI $(TT int opCmp(Object)))
	)

	$(P $(TT hash_t) is an alias to an integral type.)

	$(P Note that the parameter to $(TT opCmp) and $(TT opEquals) is
	of type
	$(TT Object), not the type of the class in which it is defined.)

	$(P For example:)

---
class Foo
{
    int a, b;

    override hash_t $(B toHash)() { return a + b; }

$(V1      override int $(B opEquals)(Object o))$(V2      override bool $(B opEquals)(Object o))
    {	
        Foo foo = cast(Foo) o;
        return foo && a == foo.a && b == foo.b;
    }

    override int $(B opCmp)(Object o)
    {	
        Foo foo = cast(Foo) o;
        if (!foo)
            return -1;
        if (a == foo.a)
            return b - foo.b;
        return a - foo.a;
    }
}
---

	$(P The implementation may use either $(TT opEquals) or $(TT opCmp) or
	both. Care should be taken so that the results of
	$(TT opEquals) and $(TT opCmp) are consistent with each other when
	the class objects are the same or not.)

<h3>Using Structs or Unions as the KeyType</h3>

	$(P If the $(I KeyType) is a struct or union type,
	a default mechanism is used
	to compute the hash and comparisons of it based on the binary
	data within the struct value. A custom mechanism can be used
	by providing the following functions as struct members:
	)

---------
$(V2 const) hash_t $(B toHash)();
$(V1 int $(B opEquals)($(I KeyType)* s);)$(V2 const bool $(B opEquals)(ref const $(I KeyType) s);)
$(V1 int $(B opCmp)($(I KeyType)* s);)$(V2 const int $(B opCmp)(ref const $(I KeyType) s);)
---------

	$(P For example:)

---------
import std.string;

struct MyString
{
    string str;
$(V1      hash_t $(B toHash)()
    {   
        hash_t hash;
        foreach (char c; s)
            hash = (hash * 9) + c;
        return hash;
    }

    bool $(B opEquals)(MyString* s)
    {
        return std.string.cmp(this.str, s.str) == 0;
    }

    int $(B opCmp)(MyString* s)
    {
        return std.string.cmp(this.str, s.str);
    })
$(V2      const hash_t $(B toHash)()
    {   
        hash_t hash;
        foreach (char c; str)
            hash = (hash * 9) + c;
        return hash;
    }

    const bool $(B opEquals)(ref const MyString s)
    {
        return std.string.cmp(this.str, s.str) == 0;
    }

    const int $(B opCmp)(ref const MyString s)
    {
        return std.string.cmp(this.str, s.str);
    })
}
---------


	$(P The implementation may use either $(TT opEquals) or $(TT opCmp) or
	both. Care should be taken so that the results of
	$(TT opEquals) and $(TT opCmp) are consistent with each other when
	the struct/union objects are the same or not.)

<h3>Properties</h3>

Properties for associative arrays are:

    $(TABLE2 Associative Array Properties,
	$(TR $(TH Property) $(TH Description))

	$(TR
	$(TD $(B .sizeof))
	$(TD Returns the size of the reference to the associative
	array; it is typically 8.
	)
	)

	$(TR
	$(TD $(B .length))
	$(TD Returns number of values in the associative array.
	Unlike for dynamic arrays, it is read-only.
	)
	)

	$(TR
	$(TD $(B .keys))
	$(TD Returns dynamic array, the elements of which are the keys in
	the associative array.
	)
	)

	$(TR
	$(TD $(B .values))
	$(TD Returns dynamic array, the elements of which are the values in
	the associative array.
	)
	)

	$(TR
	$(TD $(B .rehash))
	$(TD Reorganizes the associative array in place so that lookups
	are more efficient. rehash is effective when, for example,
	the program is done loading up a symbol table and now needs
	fast lookups in it.
	Returns a reference to the reorganized array.
	)
	)

$(V2
	$(TR
	$(TD $(B .byKey()))
	$(TD Returns a delegate suitable for use as an $(I Aggregate) to
	a $(LINK2 statement.html#ForeachStatement, $(I ForeachStatement))
	which will iterate over the keys
	of the associative array.
	)
	)

	$(TR
	$(TD $(B .byValue()))
	$(TD Returns a delegate suitable for use as an $(I Aggregate) to
	a $(LINK2 statement.html#ForeachStatement, $(I ForeachStatement))
	which will iterate over the values
	of the associative array.
	)
	)

	$(TR
	$(TD $(B .get(Key key, lazy Value defaultValue)))
	$(TD Looks up $(I key); if it exists returns corresponding $(I value)
	else evaluates and returns $(I defaultValue).
	)
	)
)
    )

<hr>
<h3>Associative Array Example: word count</h3>

---------
import std.array;
import std.stdio;
import std.ctype;

void main(string[] args)
{
    int word_total;
    int line_total;
    int char_total;
    int[string] dictionary;
    string separator = replicate("-", 42);  // dash separator

    args.popFront;  // remove program name
    foreach (arg; args)
    {
        string input;  // input buffer
        int word_count, line_count, char_count;
        int inword;
        int wstart;

        // read text file into buffer
        input = std.file.readText(arg);

        foreach (j, dchar c; input)
        {
            if (c == '\n')
                ++line_count;

            if (isdigit(c))
            {
            }
            else if (isalpha(c))
            {
                if (!inword)
                {
                    wstart = j;
                    inword = 1;
                    ++word_count;
                }
            }
            else if (inword)
            {
                string word = input[wstart .. j];
                dictionary[word]++;  // increment count for word
                inword = 0;
            }

            ++char_count;
        }

        if (inword)
        {
            string word = input[wstart .. input.length];
            dictionary[word]++;
        }

        writeln(separator);
        writeln("   lines   words   bytes   file");
        writefln("   %-8s%-8s%-8s%-8s", line_count, word_count, char_count, arg);
        writeln(separator);
        
        line_total += line_count;
        word_total += word_count;
        char_total += char_count;
    }

    if (args.length)
    {
        writeln(separator);
        writeln("total:\n   lines   words   bytes   files");
        writefln("   %-8s%-8s%-8s%-8s", line_total, word_total, char_total, args.length);
        writeln(separator);
    }

    if (dictionary.length)
    {
        writefln("\nCount of each word occurrence:\n");
        foreach (word; dictionary.keys.sort)
        {
            writefln("%3s %s", dictionary[word], word);
        }
    }
}
---------

)

Macros:
	TITLE=Associative Arrays
	WIKI=AssociativeArrays
	CATEGORY_SPEC=$0
	DOLLAR=$
	FOO=
